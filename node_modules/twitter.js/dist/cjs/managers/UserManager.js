"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UserManager_instances, _UserManager_fetchSingleUser, _UserManager_fetchMultipleUsers, _UserManager_fetchSingleUserByUsername, _UserManager_fetchMultipleUsersByUsernames;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserManager = void 0;
const util_1 = require("../util");
const BaseManager_1 = require("./BaseManager");
const errors_1 = require("../errors");
const books_1 = require("../books");
const structures_1 = require("../structures");
/**
 * The manager class that holds API methods for {@link User} objects and stores their cache
 */
class UserManager extends BaseManager_1.BaseManager {
    /**
     * @param client The logged in {@link Client} instance
     */
    constructor(client) {
        super(client, structures_1.User);
        _UserManager_instances.add(this);
    }
    /**
     * Resolves a user resolvable to its respective {@link User} object.
     * @param userResolvable An ID or instance that can be resolved to a user object
     * @returns The resolved user object
     */
    resolve(userResolvable) {
        const user = super.resolve(userResolvable);
        if (user)
            return user;
        if (userResolvable instanceof structures_1.SimplifiedUser)
            return super.resolve(userResolvable.id);
        return null;
    }
    /**
     * Resolves a user resolvable to its respective id.
     * @param userResolvable An ID or instance that can be resolved to a user object
     * @returns The id of the resolved user object
     */
    resolveId(userResolvable) {
        const userId = super.resolveId(userResolvable);
        if (typeof userId === 'string')
            return userId;
        if (userResolvable instanceof structures_1.SimplifiedUser)
            return userResolvable.id;
        return null;
    }
    /**
     * Fetches users from Twitter.
     * @param options The options for fetching users
     * @returns A {@link User} or a {@link Collection} of them as a `Promise`
     */
    async fetch(options) {
        if (typeof options !== 'object')
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'options', 'object', true);
        if ('user' in options) {
            const userId = this.resolveId(options.user);
            if (!userId)
                throw new errors_1.CustomError('USER_RESOLVE_ID', 'fetch');
            return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchSingleUser).call(this, userId, options);
        }
        if ('users' in options) {
            if (!Array.isArray(options.users))
                throw new errors_1.CustomTypeError('INVALID_TYPE', 'users', 'array', true);
            const userIds = options.users.map(user => {
                const userId = this.resolveId(user);
                if (!userId)
                    throw new errors_1.CustomError('USER_RESOLVE_ID', 'fetch');
                return userId;
            });
            return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchMultipleUsers).call(this, userIds, options);
        }
        throw new errors_1.CustomError('INVALID_FETCH_OPTIONS');
    }
    /**
     * Fetches users from Twitter using their usernames.
     *
     * **âš  Use {@link UserManager.fetch} if you have IDs, because usernames are subject to change**
     * @param options The options for fetching users
     * @returns A {@link User} or a {@link Collection} of them as a `Promise`
     */
    async fetchByUsername(options) {
        if (typeof options !== 'object')
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'options', 'object', true);
        if ('username' in options) {
            const username = options.username;
            if (typeof username !== 'string')
                throw new errors_1.CustomTypeError('INVALID_TYPE', 'username', 'string', false);
            return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchSingleUserByUsername).call(this, username, options);
        }
        if ('usernames' in options) {
            if (!Array.isArray(options.usernames))
                throw new errors_1.CustomTypeError('INVALID_TYPE', 'usernames', 'array', true);
            const usernames = options.usernames.map(username => {
                if (typeof username !== 'string')
                    throw new errors_1.CustomTypeError('INVALID_TYPE', 'username in the usernames array', 'string', false);
                return username;
            });
            return __classPrivateFieldGet(this, _UserManager_instances, "m", _UserManager_fetchMultipleUsersByUsernames).call(this, usernames, options);
        }
        throw new errors_1.CustomError('INVALID_FETCH_OPTIONS');
    }
    /**
     * Follows a user on twitter.
     * @param targetUser The user to follow
     * @returns A {@link UserFollowResponse} object
     */
    async follow(targetUser) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'follow');
        const loggedInUser = this.client.me;
        if (!loggedInUser)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            target_user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const data = await this.client._api.users(loggedInUser.id).following.post(requestData);
        return new structures_1.UserFollowResponse(data);
    }
    /**
     * Unfollows a user on twitter.
     * @param targetUser The user to unfollow
     * @returns A {@link UserUnfollowResponse} object
     */
    async unfollow(targetUser) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'unfollow');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const data = await this.client._api
            .users(loggedInUserId)
            .following(userId)
            .delete(requestData);
        return new structures_1.UserUnfollowResponse(data);
    }
    /**
     * Blocks a user on twitter.
     * @param targetUser The user to block
     * @returns A {@link UserBlockResponse} object
     */
    async block(targetUser) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'block');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            target_user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const data = await this.client._api.users(loggedInUserId).blocking.post(requestData);
        return new structures_1.UserBlockResponse(data);
    }
    /**
     * Unblocks a user on twitter.
     * @param targetUser The user to unblock
     * @returns A {@link UserUnblockResponse} object
     */
    async unblock(targetUser) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'unblock');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const data = await this.client._api
            .users(loggedInUserId)
            .blocking(userId)
            .delete(requestData);
        return new structures_1.UserUnblockResponse(data);
    }
    /**
     * Mutes a user on twitter.
     * @param targetUser The user to mute
     * @returns A {@link UserMuteResponse} object
     */
    async mute(targetUser) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'mute');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const body = {
            target_user_id: userId,
        };
        const requestData = new structures_1.RequestData({ body, isUserContext: true });
        const data = await this.client._api.users(loggedInUserId).muting.post(requestData);
        return new structures_1.UserMuteResponse(data);
    }
    /**
     * Unmutes a user on twitter.
     * @param targetUser The user to unmute
     * @returns A {@link UserUnmuteResponse} object
     */
    async unmute(targetUser) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'unmute');
        const loggedInUserId = this.client.me?.id;
        if (!loggedInUserId)
            throw new errors_1.CustomError('NO_LOGGED_IN_USER');
        const requestData = new structures_1.RequestData({ isUserContext: true });
        const data = await this.client._api
            .users(loggedInUserId)
            .muting(userId)
            .delete(requestData);
        return new structures_1.UserUnmuteResponse(data);
    }
    /**
     * Fetches followers of a given user.
     * @param targetUser The user whose followers are to be fetched
     * @param maxResultsPerPage The maximum amount of users to fetch per page. The API will default this to `100` if not provided
     * @returns A tuple containing {@link FollowersBook} object and a {@link Collection} of {@link User} objects representing the first page
     */
    async fetchFollowers(targetUser, maxResultsPerPage) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'create followers book for');
        const followersBook = new books_1.FollowersBook(this.client, { userId, maxResultsPerPage });
        const firstPage = await followersBook.fetchNextPage();
        return [followersBook, firstPage];
    }
    /**
     * Fetches users followed by a given user.
     * @param targetUser The user whose followings are to be fetched
     * @param maxResultsPerPage The maximum amount of users to fetch per page. The API will default this to `100` if not provided
     * @returns A tuple containing {@link FollowingsBook} object and a {@link Collection} of {@link User} objects representing the first page
     */
    async fetchFollowings(targetUser, maxResultsPerPage) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'create following book for');
        const followingBook = new books_1.FollowingsBook(this.client, { userId, maxResultsPerPage });
        const firstPage = await followingBook.fetchNextPage();
        return [followingBook, firstPage];
    }
    /**
     * Fetches tweets liked by a given user.
     * @param targetUser The user whose liked tweet are to be fetched
     * @param maxResultsPerPage The maximum amount of tweets to fetch per page
     * @returns A tuple containing {@link LikedTweetsBook} object and a {@link Collection} of {@link Tweet} objects representing the first page
     */
    async fetchLikedTweets(targetUser, maxResultsPerPage) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'create liked book for');
        const likedTweetBook = new books_1.LikedTweetsBook(this.client, { userId, maxResultsPerPage });
        const firstPage = await likedTweetBook.fetchNextPage();
        return [likedTweetBook, firstPage];
    }
    /**
     * Fetches tweets composed by a twitter user.
     * @param targetUser The user whose tweets are to be fetched
     * @param options The options for fetching tweets
     * @returns A tuple containing {@link ComposedTweetsBook} object and a {@link Collection} of {@link Tweet} objects representing the first page
     */
    async fetchComposedTweets(targetUser, options) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'create tweets book for');
        const bookData = { userId };
        if (options?.afterTweet) {
            const afterTweetId = this.client.tweets.resolveId(options.afterTweet);
            if (afterTweetId)
                bookData.afterTweetId = afterTweetId;
        }
        if (options?.beforeTweet) {
            const beforeTweetId = this.client.tweets.resolveId(options.beforeTweet);
            if (beforeTweetId)
                bookData.beforeTweetId = beforeTweetId;
        }
        if (options?.afterTime) {
            const afterTimestamp = new Date(options.afterTime).getTime();
            if (afterTimestamp)
                bookData.afterTimestamp = afterTimestamp;
        }
        if (options?.beforeTime) {
            const beforeTimestamp = new Date(options.beforeTime).getTime();
            if (beforeTimestamp)
                bookData.beforeTimestamp = beforeTimestamp;
        }
        if (options?.exclude) {
            bookData.exclude = options.exclude;
        }
        if (options?.maxResultsPerPage) {
            bookData.maxResultsPerPage = options.maxResultsPerPage;
        }
        const composedTweetsBook = new books_1.ComposedTweetsBook(this.client, bookData);
        const firstPage = await composedTweetsBook.fetchNextPage();
        return [composedTweetsBook, firstPage];
    }
    /**
     * Fetches tweets that mention a given user.
     * @param targetUser The mentioned user
     * @param options The options for fetching tweets
     * @returns A tuple containing {@link MentionsBook} object and a {@link Collection} of {@link Tweet} objects representing the first page
     */
    async fetchMentions(targetUser, options) {
        const userId = this.resolveId(targetUser);
        if (!userId)
            throw new errors_1.CustomError('USER_RESOLVE_ID', 'create mentions book for');
        const bookData = { userId };
        if (options?.afterTweet) {
            const afterTweetId = this.client.tweets.resolveId(options.afterTweet);
            if (afterTweetId)
                bookData.afterTweetId = afterTweetId;
        }
        if (options?.beforeTweet) {
            const beforeTweetId = this.client.tweets.resolveId(options.beforeTweet);
            if (beforeTweetId)
                bookData.beforeTweetId = beforeTweetId;
        }
        if (options?.afterTime) {
            const afterTimestamp = new Date(options.afterTime).getTime();
            if (afterTimestamp)
                bookData.afterTimestamp = afterTimestamp;
        }
        if (options?.beforeTime) {
            const beforeTimestamp = new Date(options.beforeTime).getTime();
            if (beforeTimestamp)
                bookData.beforeTimestamp = beforeTimestamp;
        }
        if (options?.maxResultsPerPage) {
            bookData.maxResultsPerPage = options.maxResultsPerPage;
        }
        const mentionsBook = new books_1.MentionsBook(this.client, bookData);
        const firstPage = await mentionsBook.fetchNextPage();
        return [mentionsBook, firstPage];
    }
}
exports.UserManager = UserManager;
_UserManager_instances = new WeakSet(), _UserManager_fetchSingleUser = 
// #### ðŸš§ PRIVATE METHODS ðŸš§ ####
async function _UserManager_fetchSingleUser(userId, options) {
    if (!options.skipCacheCheck) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
            return cachedUser;
    }
    const queryParameters = this.client.options.queryParameters;
    const query = {
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const data = await this.client._api.users(userId).get(requestData);
    return new structures_1.User(this.client, data);
}, _UserManager_fetchMultipleUsers = async function _UserManager_fetchMultipleUsers(userIds, options) {
    const fetchedUserCollection = new util_1.Collection();
    const queryParameters = this.client.options.queryParameters;
    const query = {
        ids: userIds,
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const data = await this.client._api.users.get(requestData);
    const rawUsers = data.data;
    const rawUsersIncludes = data.includes;
    for (const rawUser of rawUsers) {
        const user = this._add(rawUser.id, { data: rawUser, includes: rawUsersIncludes }, options.cacheAfterFetching);
        fetchedUserCollection.set(user.id, user);
    }
    return fetchedUserCollection;
}, _UserManager_fetchSingleUserByUsername = async function _UserManager_fetchSingleUserByUsername(username, options) {
    if (!options.skipCacheCheck) {
        const cachedUser = this.cache.find(user => user.username === username);
        if (cachedUser)
            return cachedUser;
    }
    const queryParameters = this.client.options.queryParameters;
    const query = {
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const data = await this.client._api.users.by.username(username).get(requestData);
    return new structures_1.User(this.client, data);
}, _UserManager_fetchMultipleUsersByUsernames = async function _UserManager_fetchMultipleUsersByUsernames(usernames, options) {
    const fetchedUserCollection = new util_1.Collection();
    const queryParameters = this.client.options.queryParameters;
    const query = {
        usernames,
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const data = await this.client._api.users.by.get(requestData);
    const rawUsers = data.data;
    const rawUsersIncludes = data.includes;
    for (const rawUser of rawUsers) {
        const user = this._add(rawUser.id, { data: rawUser, includes: rawUsersIncludes }, options.cacheAfterFetching);
        fetchedUserCollection.set(user.id, user);
    }
    return fetchedUserCollection;
};
