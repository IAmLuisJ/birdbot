"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Client_instances, _Client_fetchClientUser, _Client_connectToFilteredStream, _Client_connectToSampledStream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const BaseClient_1 = require("./BaseClient");
const RESTManager_1 = require("../rest/RESTManager");
const util_1 = require("../util");
const errors_1 = require("../errors");
const managers_1 = require("../managers");
const structures_1 = require("../structures");
/**
 * The core class that exposes all the functionalities available in twitter.js
 */
class Client extends BaseClient_1.BaseClient {
    /**
     * @param options The options to initialize the client with
     */
    constructor(options) {
        super(options);
        _Client_instances.add(this);
        Object.defineProperty(this, 'token', { writable: true, enumerable: false });
        this.token = null;
        Object.defineProperty(this, 'credentials', { writable: true, enumerable: false });
        this.credentials = null;
        this.me = null;
        this.readyAt = null;
        this.rest = new RESTManager_1.RESTManager(this);
        this.tweets = new managers_1.TweetManager(this);
        this.users = new managers_1.UserManager(this);
        this.spaces = new managers_1.SpaceManager(this);
        this.lists = new managers_1.ListManager(this);
        this.filteredStreamRules = new managers_1.FilteredStreamRuleManager(this);
    }
    /**
     * A getter that returns the `routeBuilder` method of {@link RESTManager}
     * for making API requests
     *
     * **Note**: This is a shortcut made available for internal use only, users of the library need not to
     * use it and should treat it as a private field
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get _api() {
        return this.rest.routeBuilder;
    }
    /**
     * Sets the client ready to make bearer token authorized API requests.
     * Emits a `ready` event on success.
     * @param token The bearer token for the client
     * @returns The provided bearer token as a `Promise`
     *
     * @throws {@link CustomTypeError} The exception is thrown if the `token` param is not a string
     */
    async loginWithBearerToken(token) {
        if (typeof token !== 'string') {
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'token', 'string', false);
        }
        this.token = token;
        this.readyAt = new Date();
        this.emit(util_1.ClientEvents.READY, this);
        if (this.options.events.includes('FILTERED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToFilteredStream).call(this);
        }
        if (this.options.events.includes('SAMPLED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToSampledStream).call(this);
        }
        return this.token;
    }
    /**
     * Sets the client ready to make both bearer token and user context authorized API requests.
     * Emits a `ready` event on success.
     * @param credentials The credentials for the client
     * @returns The provided credentials as a `Promise`
     *
     * @throws {@link CustomTypeError} The exception is thrown if the `credentials` param is not an object
     */
    async login(credentials) {
        if (typeof credentials !== 'object') {
            throw new errors_1.CustomTypeError('INVALID_TYPE', 'credentials', 'object', true);
        }
        this.credentials = new structures_1.ClientCredentials(credentials);
        this.token = this.credentials.bearerToken;
        this.readyAt = new Date();
        this.me = await __classPrivateFieldGet(this, _Client_instances, "m", _Client_fetchClientUser).call(this, credentials.username);
        if (this.me?.username !== this.credentials.username)
            throw new errors_1.CustomError('USER_CONTEXT_LOGIN_ERROR', this.credentials.username);
        this.emit(util_1.ClientEvents.READY, this);
        if (this.options.events.includes('FILTERED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToFilteredStream).call(this);
        }
        if (this.options.events.includes('SAMPLED_TWEET_CREATE')) {
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_connectToSampledStream).call(this);
        }
        return this.credentials;
    }
}
exports.Client = Client;
_Client_instances = new WeakSet(), _Client_fetchClientUser = 
// #### ðŸš§ PRIVATE METHODS ðŸš§ ####
async function _Client_fetchClientUser(username) {
    const queryParameters = this.options.queryParameters;
    const query = {
        expansions: queryParameters?.userExpansions,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query });
    const data = await this._api.users.by.username(username).get(requestData);
    return new structures_1.ClientUser(this, data);
}, _Client_connectToFilteredStream = async function _Client_connectToFilteredStream() {
    const queryParameters = this.options.queryParameters;
    const query = {
        expansions: queryParameters?.tweetExpansions,
        'media.fields': queryParameters?.mediaFields,
        'place.fields': queryParameters?.placeFields,
        'poll.fields': queryParameters?.pollFields,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query, isStreaming: true });
    const { body } = await this._api.tweets.search.stream.get(requestData);
    if (!body)
        throw Error('No response body');
    try {
        for await (const chunk of body) {
            const buffer = Buffer.from(chunk);
            const data = buffer.toString();
            if (data === '\r\n') {
                if (this.options.events.includes('KEEP_ALIVE_SIGNAL')) {
                    this.emit(util_1.ClientEvents.KEEP_ALIVE_SIGNAL, util_1.StreamType.FILTERED);
                }
                continue;
            }
            try {
                const rawData = JSON.parse(data);
                const tweet = this.tweets._add(rawData.data.id, rawData, false);
                const matchingRules = rawData.matching_rules.reduce((col, rule) => {
                    col.set(rule.id, new structures_1.MatchingRule(rule));
                    return col;
                }, new util_1.Collection());
                this.emit(util_1.ClientEvents.FILTERED_TWEET_CREATE, tweet, matchingRules);
            }
            catch (error) {
                // twitter sends corrupted data sometimes that throws error while parsing it
            }
        }
    }
    catch (error) {
        console.log(error);
        // TODO: add a reconnection mechanism
    }
}, _Client_connectToSampledStream = async function _Client_connectToSampledStream() {
    const queryParameters = this.options.queryParameters;
    const query = {
        expansions: queryParameters?.tweetExpansions,
        'media.fields': queryParameters?.mediaFields,
        'place.fields': queryParameters?.placeFields,
        'poll.fields': queryParameters?.pollFields,
        'tweet.fields': queryParameters?.tweetFields,
        'user.fields': queryParameters?.userFields,
    };
    const requestData = new structures_1.RequestData({ query, isStreaming: true });
    const { body } = await this._api.tweets.sample.stream.get(requestData);
    if (!body)
        throw Error('No response body');
    try {
        for await (const chunk of body) {
            const buffer = Buffer.from(chunk);
            const data = buffer.toString();
            if (data === '\r\n') {
                if (this.options.events.includes('KEEP_ALIVE_SIGNAL')) {
                    this.emit(util_1.ClientEvents.KEEP_ALIVE_SIGNAL, util_1.StreamType.SAMPLED);
                }
                continue;
            }
            try {
                const rawTweet = JSON.parse(data);
                const tweet = this.tweets._add(rawTweet.data.id, rawTweet, false);
                this.emit(util_1.ClientEvents.SAMPLED_TWEET_CREATE, tweet);
            }
            catch (error) {
                // twitter sends corrupted data sometimes that throws error while parsing it
            }
        }
    }
    catch (error) {
        console.log(error);
        // TODO: add a reconnection mechanism
    }
};
