"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestHandler = void 0;
const promises_1 = require("timers/promises");
const async_queue_1 = require("@sapphire/async-queue");
const TwitterAPIError_1 = require("./TwitterAPIError");
const util_1 = require("../util");
class RequestHandler {
    constructor(manager) {
        this.manager = manager;
        this.queue = new async_queue_1.AsyncQueue();
    }
    async push(request) {
        await this.queue.wait();
        try {
            return await this.execute(request);
        }
        finally {
            this.queue.shift();
        }
    }
    async execute(request) {
        const res = await request.make();
        if (res.ok) {
            if (request.isStreaming)
                return res;
            const parsedResponse = (await (0, util_1.parseResponse)(res));
            if ('errors' in parsedResponse) {
                if (this.manager.client.options.events.includes('PARTIAL_ERROR')) {
                    /**
                     * Emitted when the raw data of a 200 OK API response contains error along with the requested data.
                     * Use this to debug what fields are missing and why
                     */
                    this.manager.client.emit(util_1.ClientEvents.PARTIAL_ERROR, parsedResponse.errors);
                }
                // Throw error if there is no data field in the response as there is nothing to process. (⚠ not sure this is true for every response, will look this up later)
                // Currently the thrown error will contain information about the first error only, listen for `partialError` to get the complete error object
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                if ('data' in parsedResponse === false)
                    throw new TwitterAPIError_1.TwitterAPIError(parsedResponse.errors[0]); // TODO
            }
            return parsedResponse;
        }
        else {
            if (request.isStreaming) {
                // It seems that there is some kind of latency issue with the filtered tweets stream endpoint,
                // where the server thinks that the client is connecting with a simultaneous second connection
                // whereas the client is actually connecting to the stream “again” after disconnecting.
                // Hence, Wait for an arbitrary 20s period before initiating a new connection to the stream.
                await (0, promises_1.setTimeout)(20000); // TODO: Remove this once the latency issue has been fixed
                return this.execute(request);
            }
            const apiError = (await (0, util_1.parseResponse)(res));
            throw new TwitterAPIError_1.TwitterAPIError(apiError);
        }
    }
}
exports.RequestHandler = RequestHandler;
